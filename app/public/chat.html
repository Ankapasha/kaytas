<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chatt — Kaytas</title>

  <style>
    :root{
      --bg: #f5f6f8;
      --card: #ffffff;
      --muted: #7a7a7a;
      --accent: #1976d2;
      --bubble-me: #1976d2;
      --bubble-other: #e9ecef;
      --text-me: #fff;
      --text-other: #222;
    }

    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial}
    .container{max-width:1200px;margin:20px auto;display:flex;gap:20px;padding:0 16px;height:calc(100vh - 40px)}
    .panel{background:var(--card);border-radius:10px;box-shadow:0 2px 8px rgba(15,20,25,0.05);overflow:hidden}

/* LEFT: conversations */
    .conversations{width:34%;display:flex;flex-direction:column}
    .conv-search{padding:12px;border-bottom:1px solid #eee;display:flex;gap:8px;align-items:center}
    .conv-search input{flex:1;padding:8px;border-radius:8px;border:1px solid #ddd}
    .conv-list{overflow:auto;flex:1}
    .conv-item{display:flex;gap:12px;padding:12px;border-bottom:1px solid #f1f1f1;cursor:pointer;align-items:center;position:relative}
    .conv-item:hover{background:#fbfbfb}
    .conv-thumb{width:64px;height:52px;background:#ddd;border-radius:6px;flex-shrink:0;display:flex;align-items:center;justify-content:center;font-weight:600;color:#555}
    .conv-meta{flex:1;min-width:0}
    .conv-title{font-weight:600;font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .conv-sub{font-size:13px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .conv-time{font-size:12px;color:var(--muted);flex-shrink:0}

/* badge (new) */
    .new-badge {
      width:10px;
      height:10px;
      border-radius:50%;
      background:#e53935;
      position:absolute;
      left:8px;
      top:18px;
      box-shadow:0 0 0 3px rgba(229,57,53,0.08);
    }

/* RIGHT: chat */
    .chat{flex:1;display:flex;flex-direction:column;height:100%}
    .chat-header{padding:12px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;gap:12px}
    .chat-title{font-weight:700}
    .chat-ad{font-size:13px;color:var(--muted)}
    .messages{flex:1;padding:18px;overflow:auto;background:linear-gradient(#fbfcfd,#f7f8fa)}
    .msg-row{display:flex;margin-bottom:12px;align-items:flex-end}
    .msg-row.me{justify-content:flex-end}
    .bubble{max-width:70%;padding:10px 14px;border-radius:14px;font-size:14px;line-height:1.3}
    .bubble.me{background:var(--bubble-me);color:var(--text-me);border-bottom-right-radius:6px}
    .bubble.other{background:var(--bubble-other);color:var(--text-other);border-bottom-left-radius:6px}
    .msg-meta{font-size:12px;color:var(--muted);margin-top:6px}
    .composer{padding:12px;border-top:1px solid #eee;display:flex;gap:8px;align-items:center}
    .composer textarea{flex:1;padding:10px;border-radius:10px;border:1px solid #ddd;resize:none;height:56px;font-size:14px}
    .send-btn{background:var(--accent);color:white;border:none;padding:12px 14px;border-radius:10px;cursor:pointer;font-weight:700}
    .send-btn[disabled]{opacity:0.6;cursor:not-allowed}

    .typing{font-size:13px;color:var(--muted);padding-left:12px;padding-bottom:6px}

    @media (max-width:900px){
      .container{flex-direction:column;height:auto}
      .conversations{width:100%;height:220px}
      .chat{height:calc(100vh - 300px)}
    }
  </style>
</head>
<body>

<div class="container">
  <div class="panel conversations">
    <div class="conv-search">
      <input id="convSearch" placeholder="Sök konversation eller annons..." />
    </div>

    <div class="conv-list" id="convList">
      <div style="padding:18px;color:var(--muted)">Laddar konversationer…</div>
    </div>
  </div>

  <div class="panel chat">
    <div class="chat-header">
      <div style="flex:1">
        <div class="chat-title" id="chatTitle">Välj en konversation</div>
        <div class="chat-ad" id="chatAd"></div>
      </div>
      <div id="chatActions"></div>
    </div>

    <div class="messages" id="messages">
      <div style="padding:18px;color:var(--muted)">Ingen konversation vald.</div>
    </div>

    <div class="typing" id="typingIndicator" style="display:none">Skriver...</div>

    <div class="composer">
      <textarea id="messageInput" placeholder="Skriv meddelande..." rows="2"></textarea>
      <button id="sendBtn" class="send-btn">Skicka</button>
    </div>
  </div>
</div>

<script>
  // ============================
  // Chat client
  // Backend endpoints expected:
  // GET  /api/messages/conversations
  // GET  /api/messages/thread/:otherUserId/:adId
  // POST /api/messages/send { receiverId, adId, content }
  // ============================

  const pollIntervalMs = 5000;
  let pollingHandle = null;

  const convListEl = document.getElementById('convList');
  const messagesEl = document.getElementById('messages');
  const chatTitleEl = document.getElementById('chatTitle');
  const chatAdEl = document.getElementById('chatAd');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const typingIndicator = document.getElementById('typingIndicator');
  const convSearch = document.getElementById('convSearch');

  let conversations = [];
  let active = null; // { otherUserId, adId, convObj }
  let token = localStorage.getItem('token');

  // -------------------------
  // Local unread tracking (per-conversation)
  // -------------------------
  function getLastReadStamp(otherUserId, adId) {
    if (!otherUserId || !adId) return 0;
    return Number(localStorage.getItem("chat_last_read_" + otherUserId + "_" + adId)) || 0;
  }

  function setLastReadStamp(otherUserId, adId) {
    if (!otherUserId || !adId) return;
    localStorage.setItem("chat_last_read_" + otherUserId + "_" + adId, Date.now());
  }

  // Redirect to login if not logged in
  function ensureLogin() {
    token = localStorage.getItem('token');
    if (!token) {
      const redirect = '/chat.html' + window.location.search;
      window.location.href = '/login.html?redirect=' + encodeURIComponent(redirect);
      return false;
    }
    return true;
  }

  if (!ensureLogin()) {
    // stops execution — user redirected
  }

  function authHeaders() {
    const t = localStorage.getItem('token');
    return t ? { Authorization: 'Bearer ' + t, 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json' };
  }

  function formatTime(ts) {
    try {
      const d = new Date(ts);
      return d.toLocaleString();
    } catch { return ''; }
  }

  async function handleAuthError(res) {
    if (res && (res.status === 401 || res.status === 403)) {
      localStorage.removeItem('token');
      ensureLogin();
      return true;
    }
    return false;
  }

  async function loadConversations() {
    convListEl.innerHTML = '<div style="padding:14px;color:var(--muted)">Laddar konversationer…</div>';
    try {
      const res = await fetch('/api/messages/conversations', { headers: authHeaders() });
      if (await handleAuthError(res)) return;
      if (!res.ok) {
        convListEl.innerHTML = '<div style="padding:14px;color:var(--muted)">Kunde inte hämta konversationer.</div>';
        return;
      }
      const data = await res.json();
      conversations = Array.isArray(data) ? data : [];
      renderConvList();
    } catch (err) {
      console.error('Konv fetch error', err);
      convListEl.innerHTML = '<div style="padding:14px;color:var(--muted)">Fel vid hämtning.</div>';
    }
  }

  function renderConvList(filter = '') {
    convListEl.innerHTML = '';
    const filtered = conversations.filter(c => {
      const other = (c._id && c._id.otherUser) ? (c._id.otherUser.name || c._id.otherUser.email || '') : '';
      const adTitle = (c.adId && c.adId.title) ? c.adId.title : '';
      const last = c.lastMessage || '';
      const text = (other + ' ' + adTitle + ' ' + last).toLowerCase();
      return text.includes(filter.toLowerCase());
    });

    if (filtered.length === 0) {
      convListEl.innerHTML = '<div style="padding:18px;color:var(--muted)">Inga konversationer.</div>';
      return;
    }

    filtered.forEach(c => {
      const other = (c._id && c._id.otherUser) ? c._id.otherUser : null;
      const ad = c.adId || (c._id && c._id.adId) ? (c.adId || c._id.adId) : null;

      const otherId = other ? (other._id || other.id || other) : '';
      const adIdVar = ad ? (ad._id || ad.id || ad) : '';

      const item = document.createElement('div');
      item.className = 'conv-item';
      item.dataset.other = otherId;
      item.dataset.ad = adIdVar;

      const thumb = document.createElement('div');
      thumb.className = 'conv-thumb';
      thumb.textContent = (ad && ad.title) ? (ad.title.substring(0,2).toUpperCase()) : 'AD';

      const meta = document.createElement('div');
      meta.className = 'conv-meta';

      const title = document.createElement('div');
      title.className = 'conv-title';
      title.textContent = other ? (other.name || other.email || 'N/A') : 'Okänd';

      const sub = document.createElement('div');
      sub.className = 'conv-sub';
      sub.textContent = (ad && ad.title ? ad.title + ' — ' : '') + (c.lastMessage || '');

      const time = document.createElement('div');
      time.className = 'conv-time';
      time.textContent = formatTime(c.timestamp);

      meta.appendChild(title);
      meta.appendChild(sub);

      // Determine unread: compare conversation timestamp with stored "last read"
      const convTs = (c.timestamp) ? (new Date(c.timestamp)).getTime() : 0;
      const lastRead = getLastReadStamp(otherId, adIdVar);

      if (convTs > lastRead && lastRead > 0) {
        // show badge ONLY if we've previously read (lastRead>0) and there's newer content
        const badge = document.createElement('div');
        badge.className = 'new-badge';
        item.appendChild(badge);
      } else if (convTs > lastRead && lastRead === 0) {
        // if never read and there is a message, show badge as well
        // avoid showing badge for empty conversations with null timestamp
        if (convTs > 0) {
          const badge2 = document.createElement('div');
          badge2.className = 'new-badge';
          item.appendChild(badge2);
        }
      }

      item.appendChild(thumb);
      item.appendChild(meta);
      item.appendChild(time);

      item.addEventListener('click', () => {
        openConversation(item.dataset.other, item.dataset.ad, c);
      });

      convListEl.appendChild(item);
    });
  }

  async function openConversation(otherUserId, adId, convObj = null) {
    if (!otherUserId || !adId) return;
    active = { otherUserId, adId, convObj };

    const otherName = (convObj && convObj._id && convObj._id.otherUser) ? (convObj._id.otherUser.name || convObj._id.otherUser.email) : '';
    chatTitleEl.textContent = otherName || 'Konversation';
    chatAdEl.textContent = convObj && convObj.adId && convObj.adId.title ? convObj.adId.title : '';

    // mark as read now (clear badge)
    setLastReadStamp(otherUserId, adId);

    messagesEl.innerHTML = '<div style="padding:18px;color:var(--muted)">Laddar meddelanden…</div>';
    await loadThread();

    if (pollingHandle) clearInterval(pollingHandle);
    pollingHandle = setInterval(async () => {
      await loadThread(false);
      await loadConversations();
    }, pollIntervalMs);
  }

  async function loadThread(shouldScroll = true) {
    if (!active) return;
    try {
      const res = await fetch(`/api/messages/thread/${active.otherUserId}/${active.adId}`, { headers: authHeaders() });
      if (await handleAuthError(res)) return;
      if (!res.ok) {
        messagesEl.innerHTML = '<div style="padding:18px;color:var(--muted)">Kunde inte hämta konversation.</div>';
        return;
      }
      const msgs = await res.json();
      renderMessages(msgs, shouldScroll);
    } catch (err) {
      console.error('Thread fetch error', err);
      messagesEl.innerHTML = '<div style="padding:18px;color:var(--muted)">Fel vid hämtning av meddelanden.</div>';
    }
  }

  function renderMessages(list, shouldScroll = true) {
    messagesEl.innerHTML = '';
    if (!Array.isArray(list) || list.length === 0) {
      messagesEl.innerHTML = '<div style="padding:18px;color:var(--muted)">Inga meddelanden ännu. Skriv något för att starta konversationen.</div>';
      return;
    }

    const myId = getMyIdFromToken();

    list.forEach(m => {
      const senderId = (m.sender && (m.sender._id || m.sender.id || m.sender)) || null;
      const isMe = senderId && myId && String(senderId) === String(myId);

      const row = document.createElement('div');
      row.className = 'msg-row ' + (isMe ? 'me' : 'other');

      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + (isMe ? 'me' : 'other');
      bubble.textContent = m.content || m.text || m.message || '';

      row.appendChild(bubble);

      const meta = document.createElement('div');
      meta.className = 'msg-meta';
      meta.style.width = '100%';
      meta.style.textAlign = isMe ? 'right' : 'left';
      meta.textContent = (m.sender && m.sender.name ? m.sender.name + ' • ' : '') + (formatTime(m.timestamp || m.createdAt || m.created) || '');
      row.appendChild(meta);

      messagesEl.appendChild(row);
    });

    if (shouldScroll) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  sendBtn.addEventListener('click', async () => {
    await sendMessage();
  });

  messageInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      await sendMessage();
    }
  });

  let typingTimeout = null;
  messageInput.addEventListener('input', () => {
    if (messageInput.value.length > 0) {
      typingIndicator.style.display = 'block';
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => typingIndicator.style.display = 'none', 1000);
    } else {
      typingIndicator.style.display = 'none';
    }
  });

  async function sendMessage() {
    if (!active) return alert('Välj en konversation först.');
    const text = messageInput.value.trim();
    if (!text) return;

    sendBtn.disabled = true;
    const payload = {
      receiverId: active.otherUserId,
      adId: active.adId,
      content: text
    };

    try {
      const res = await fetch('/api/messages/send', {
        method: 'POST',
        headers: authHeaders(),
        body: JSON.stringify(payload)
      });

      if (await handleAuthError(res)) return;
      if (!res.ok) {
        const txt = await res.text().catch(()=>null);
        alert('Kunde inte skicka meddelande: ' + (txt || res.status));
        sendBtn.disabled = false;
        return;
      }

      // mark as read (we just sent a message in this conversation)
      setLastReadStamp(active.otherUserId, active.adId);

      messageInput.value = '';
      typingIndicator.style.display = 'none';
      await loadThread();
      await loadConversations();
    } catch (err) {
      console.error('Send error', err);
      alert('Fel vid sändning.');
    } finally {
      sendBtn.disabled = false;
    }
  }

  function getMyIdFromToken() {
    const t = localStorage.getItem('token');
    if (!t) return null;
    try {
      const payload = JSON.parse(atob(t.split('.')[1]));
      return payload.id || payload._id || null;
    } catch (e) { return null; }
  }

  (async function init() {
    if (!ensureLogin()) return;

    await loadConversations();

    // Support opening conversation by query params:
    // - ?other=<userId>&ad=<adId>
    // - or ?adId=<adId>&seller=<sellerId> (used from listing page)
    const params = new URLSearchParams(window.location.search);
    const other = params.get('other');
    const ad = params.get('ad');
    const adId = params.get('adId');
    const seller = params.get('seller');

    if (other && ad) {
      const conv = conversations.find(c => {
        const otherId = c._id && c._id.otherUser && (c._id.otherUser._id || c._id.otherUser.id);
        const adIdLocal = (c.adId && (c.adId._id || c.adId.id)) || (c._id && c._id.adId);
        return (String(otherId) === String(other) && String(adIdLocal) === String(ad));
      });
      openConversation(other, ad, conv || null);
      return;
    }

    if (adId && seller) {
      // open conversation for seller & adId even if not in conv list yet
      openConversation(seller, adId, null);
      return;
    }

    convSearch.addEventListener('input', (e) => {
      renderConvList(e.target.value);
    });

    // Periodic refresh of conversation list
    setInterval(async () => {
      await loadConversations();
    }, pollIntervalMs);
  })();

  window.addEventListener('beforeunload', () => {
    if (pollingHandle) clearInterval(pollingHandle);
  });
</script>

</body>
</html>